% Chapter: contains the system architecture

%For every one: use as many diagrams as possible :) (author Petr)

The architecture of \textan{} is based on client-server model. Two main components
are the \textan{} server and \textan{} client which communicate via W3C web services
(SOAP protokol).



\comment{Ondrej}{Mention why it was split like this - a wish from outside, but in the future fully automated (tuned) annotation without client}



\section{Server architecture}

The server architecture is based on a logical multilayered architecture. It
consists of 5 layers: a presentation layer, a service layer, a business logic layer, 
a persistence layer and a data layer.

\comment{Ondrej}{it definitely needs a figure here, but no generalized pictures, it needs your concrete components and connection. The 5 layers sound like textbook example}

\comment{Adam}{The comment above was created when there were no pictures nor subsections here, but I have added it anyway, just to be sure}

\begin{figure}[!htb]
        \centering
        \includegraphics{Images/ServerComponentOverview}
        \caption{Overview of the server layered architecture.}
        \label{fig:ServerComponentOverview}
\end{figure}



\subsection{Web service layer}


\comment[Petr]{Petr}{CXF, java code generation form wsdl, web services implementation
 ->  facade over services, jetty}

\subsection{Service layer}
The service layer is component that consists from classes which handle requests
using underlying layers and register commands in the scheduler. These classes are
placed in the package \emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-server.\-services}
and the package \emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-server.\-models}. The layer
is totally independent from the web service layer. \comment{Petr}{Move this sentence into section about the web service layer.}

\comment[Petr]{Petr}{Describe all services}

\subsection{Business layer}
The business layer contains components which encapsulate the main functionality
of the system. The layer is consists of two main components, the Named Entity
recognizer and the Object assign. Both of them use machine learning methods to solve
their task. They access the persistence layer to obtain training data and they
are called from the service layer and the scheduler.

\subsubsection{Named entity recognizer architecture}

Named entity architecture is divided to two parts, recognition and training.
\paragraph{Recognition} 
Recognition is slitted to two parts - Java part and C++ part. This is because
NameTag, which we use as named entity recognizer, is written mainly in C++ and
TextAn in Java, so we must use JNI to call functions from C++ through provided
Java bindings. C++ part is represented by NameTag, so it has its own documentation.
Java part contains JNI bindings to call C++ part and than connection to TextAn.
This part serves as an adaptor between these two projects. Its main task is
to translate recognized NameTag entities to entities stored in TextAn database.
Because of optimization, this component caches database entities.

\paragraph{Training}
Despite the fact that NameTag is in C++ and TextAn in Java, it is not requisite 
to implement JNI, because training is called as binary files and the model is generated
as file. So calling C++ functions is not needed here. Java part provides
training data collecting from database and preparation, model handling
(deleting old ones. binding them to NameTag).
\comment[Jakub, Petr]{Tam}{Approved?}

\subsubsection{Object assigner architecture} \comment{Petr}{or simply TextPro?}

\comment[Tam]{Petr}{here should be description of TextPro}

%After the document is processed by NER, the next step is assigning the entities
%to available objects in the database. Normally, this could be done by matching
%the entity text with the alias from object. However, this method would \comment[Tam]{Petr}{finish?}

After running NameTag, a list of entities is extracted from the document. The
package \emph{cz.cuni.mff.ufal.textan.textpro} is responsible for automatic
assigning of those entities to available objects in database. At the end, for 
each entity, the aforementioned package returns a list of potential objects along
with their score. Two methods are provided.

\paragraph{HeuristicRank}
The most simplest solution is searching for the \textit{objects} with matching 
\textit{alias}. However, for an array of entity, it would return an array of 
list of unordered objects.
Function \emph{cz.cuni.mff.ufal.textan.textpro.HeuristicRanking} loops through 
the whole structure, promote the pair of objects which has a relation. This is 
due to the fact that such pair of objects is more likely to appear in the same
document. However, as a heuristic method, its main role is to guarantee a decent
output for every input.

\comment{Tam}{TODO: Picture for heuristic ranking}

\paragraph{MachineLearning}
Without extensive human effort, machine learning is the best method to achieve
high performance from a huge database. The problem of ``matching potential objects
to an entity'' is reformulated to fit the definition of a classification machine 
learning. Each object is paired with the entity. Then the pair is classified as
\emph{positive} if the object is potentially matched the entity. On the contrary,
the pair is classified as \emph{negative}. It becomes the problem of binary 
classification.

\paragraph{Learning}
The package \emph{cz.cuni.mff.ufal.textan.textpro.data} supports all steps for machine
learning including training (learning). The database is extracted. 
\emph{cz.cuni.mff.ufal.textan.textpro.data} creates 
artificial pairs of training vectors with \textit{Weka} tool. When a new document is
processed, new entity and object pairs is added to the database. They could be extracted
later to train again.

\paragraph{Testing}
To assign the entity to object, function \emph{distributionForInstance} to return the 
probability of the pair with regards to \emph{positive} class. The probability value 
is ranked an used as the score.

\comment{Tam}{TODO: Features description, maybe}

\subsection{Scheduler}
The scheduler is a simple component, that invokes commands asynchronously against
requests in the servlet container. It is implemented by classes in the package
\emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-server.\-commands}. \comment{Petr}{Add class diagram?}

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/Commands}
        \caption{Overview of the scheduler classes.}
        \label{fig:CommandsOverview}
\end{figure}

The component is used to invoke re-learning in components from the business layer.
The learning is typically slow, in a matter of minutes, so it's necessary to use
this approach due to system performance. Commands are registered from methods in
the service layer that modify data used for learning. Commands are stored in one
FIFO queue and are invoked in one thread, so it's possible to filter them before
invocation. This ability ensures that only one learning command is invoked at one
time and that learning commands are not invoked unreasonably. Components from
the business layer use old models during learning, so the re-learning is a transparent
operation for users.

\subsection{Persistence layer}

\comment[Venca]{Petr}{Describe DAOs, database mapping, underlying database etc.}

\comment[Petr]{Petr}{Describe full text indexing: hibernate search, lucene, a their mappings}

\comment[Petr]{Petr}{Describe new Czech analyzer}

\subsection{Database}

\comment[Venca]{Petr}{Describe database: database schema etc.}


\section{Client architecture}

\comment[Adam]{Petr}{here should be description of client architecture (MVC etc.)}

\comment{Tam}{NOTE: your sentences are way too long :)}

\textan{} client consist of two main parts. The package
\emph{cz.cuni.mff.ufal.textan.core} and its subpackages handle communication
with webservices and completely hides them from the package
\emph{cz.cuni.mff.ufal.textan.core} and its subpackages which are responsible
for actual displaying the user interface (see figure \ref{fig:ClientOverview}).
It means that the model representation is duplicite to classes generated from
the WSDL by CXF into \emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-commons.\-model}
and \emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-commons.\-ws} and their subpackages.
On the other hand this approach has great advantage - webservice interface
changes will require only code refactoring localized into \emph{core.*}
packages. There is also \emph{cz.\-cuni.\-mff.\-ufal.\-textan.\-tui} package
containing a simple batch report processor without user interaction.

\begin{figure}[!htb]
        \centering
        \includegraphics[width=10cm]{Images/ClientOverview}
        \caption{Overview of the packages.}
        \label{fig:ClientOverview}
\end{figure}

For visualization itself JavaFX framework is used. It naturaly enforces
Model-View-Controller architecture.

In the rest of the section the most important packages will be introduced and
described.

\subsection{Model - cz.cuni.mff.ufal.textan.core}

Model classes can be found in this package. It contains mainly client side
representation of object, entity, relation, document etc. (see figure \ref{fig:CorePackage}). Most important class
is \emph{Client} which is used for communication with the webservices. It also
serves as a factory of \emph{ProcessReportPipeline} (see
\ref{sssec:ReportPipeline}). There are also \emph{SynchronizedDataProvider} and
\emph{SynchronizedDocumentProcessor} to provide sychronization for
\emph{IDataProvider} and \emph{IDocumentProcessor} created by CXF.

Subpackages of the \emph{Core} package focus on individual client side tasks,
like displaying graphs and processing report in a pipeline.

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/CorePackage}
        \caption{Overview of the most important features of \emph{core} package.}
        \label{fig:CorePackage}
\end{figure}

\subsubsection{cz.cuni.mff.ufal.textan.core.reportpipeline}
\label{sssec:ReportPipeline}

This package contains classes necessary for report processing (see figure
\ref{fig:CorePackage}). Most importantly there is class
\emph{ProcessReportPipeline} that holds information about processing one report.
The pipeline/wizard approach was chosen because the amount of choices and
required tasks would be overhelming to users if they were all provided at once.
Virtually all methods of the pipeline object are delegated to its \emph{State}
(see figure \ref{fig:Pipeline}). Descendants of the class \emph{State} are
singletons. They contain most of the pipeline processing logic and control to
which state the pipeline should go next. When this happens, each registered
\emph{IStateChangedListener} is notified.

\begin{figure}[!htb]
        \centering
        \includegraphics[height=16cm]{Images/Pipeline}
        \caption{Pipeline state machine.}
        \label{fig:Pipeline}
\end{figure}

\subsubsection{cz.cuni.mff.ufal.textan.core.reportpipeline.load}

This package contains classes needed for importing report texts from extenal
files. There is \emph{IImport} interface that provides methods for extracting
text from an array of bytes. Custom implementations of \emph{IImporter} need
to be registered to class \emph{ImportManager} to be selectable by users. The
rest of the package is a few classes providing import of text files in most
common encodings.

\subsubsection{cz.cuni.mff.ufal.textan.core.graph}

This package contains several classes related to creating graphs. They handle
mostly graph filtering which is done solely on client side. See figure
\ref{fig:Graph}.

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/Graph}
        \caption{Overview of the \emph{graph} package.}
        \label{fig:Graph}
\end{figure}

\subsection{Controller and View - cz.cuni.mff.ufal.textan.gui}

This package and its subpackages contain controller classes and several view
components that had to be customized to achieve specific behaviour. A hierarchy
of controllers has been developed, mostly for code reuse (see
\ref{fig:Controllers}). Controllers extensively use \emph{core} package.

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/Controllers}
        \caption{Overview of the controllers hierarchy.}
        \label{fig:Controllers}
\end{figure}

Resources from this package and its subpackages contains descriptions of views
(*.fxml files), styles (*.css files) and localization (*.properties files).

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/Windows}
        \caption{Overview of the windows hierarchy.}
        \label{fig:Windows}
\end{figure}

\comment[Adam]{Adam}{Add schema of Word->EntityBuilder/RelationBuilder hierarchy}

\subsubsection{cz.cuni.mff.ufal.textan.gui.graph}

This package contains controllers for objects and graph views. The most
interesting class is \emph{GraphView} which embeds JUNG Swing graph into JavaFX
and inserts content of \emph{cz.cuni.mff.udal.textan.core.Graph} to JUNG graph.
Also handles hypergraph conversions if needed for which it uses auxiliary
classes \emph{DummyRelation} and \emph{RelationObject}.

Its only subpackage \emph{string} contains only class \emph{Handler}. It is a
workaround that copes with inability of JavaFX to load css style sheets from
\emph{String} which is needed for \emph{GraphViewController} to generate styles
for coloring filter list checkboxes. For that reason custom url schema "string"
has been created and \emph{Handler} resolves it with strings registered to it.

\subsection{Used Libraries}
\label{ssec:UsedLibraries}

\comment[Adam]{Adam}{Find a suitable place for this section and refactor it.}

\paragraph{ControlsFX}
ControlsFX is a Java8 open source library aiming at enhancing the programming
experience with standard JavaFX. It provides wide selection of new and improved
components to make everyday use of JavaFX even easier. \textan{} uses it mainly
for its high quality and user-friendly standard dialogs which are
incomprehensibly and sorely missing in JavaFX.

\paragraph{JCommander}
JCommander is a very small Java framework that makes it trivial to parse command
line parameters. It was chosen because of easy to used annotaion API and no
external dependencies.

\paragraph{JUNG}
JUNG (Java Universal Network/Graph Framework) is older Java library for
displaying graphs, still widely used in Java world, well documented and easily
extensible. Sadly, it does not support JavaFX, but only older Java GUI framework
SWING. Fortunately, thanks to new JavaFX8 SwingNode enabling usage of SWING
components in JavaFX scenes it was possible to seamlessly integrate JUNG into
JavaFX \textan{} Client.

\paragraph{JFXtras}
JFXtras is another JavaFX8 enhancing project. \textan{} Client uses it mostly
for its window management capabilities enabling extensible use of inner windows
embedded into the main window. Another used component is BigDecimalField which
brings common Spinner component into JavaFX.

\comment{Ondrej}{I do not know at all what I should imagine under last sentence.}

\paragraph{PretopoLib\footnote{\url{http://pretopolib.complexica.net/}}}
Although JUNG is mature and well thought library, it lacks one important feature
out-of-the-box: displaying hypergraphs. For this reason JUNG graph rendering
part of PretopoLib is used. PretopoLib is a library mainly focusing on
pretopology and graph displaying is rather byproduct. However it fully meets our
requirements and its author kindly provided us the sources so we could fix one
inconvenient detail.

\section{Comunication}
\comment[Petr (\& Adam)]{Petr}{Describe communication pattern between client and server,
sequence diagram etc.}

Usage of webservice \emph{DataProvider} is straightforward, its operations are
completely independent and are intended for viewing and manipulating
the database.

The service \emph{DocumentProcessor} is more demanding and needs its operations
called in specific order to achieve proper recognition (see figure
\ref{fig:ClientServerCommunication}). First of all, the client needs to obtain
the ticket which stores information about processing and is needed for all
following calls. For three recognition operations there are two variants. First
for processing report already stored in the database (called\emph{*ById}) and
second for inserting completely new document to the database (called
\emph{*FromString}). Operations \emph{getEntities*} recognize entities in
given report. Operations \emph{getAssignments*} assign objects from the database
to recognized entities and finally operations \emph{getRelations*} recognize
relations between objects. Please note that \emph{getRelations*} is not
implemented in this version of \textan{} and returns empty response with no
relations.

The recognition operations do not store anything into the database. For this
purpose there are three operations \emph{saveProcessedDocumentFromString} and
\emph{saveProcessedDocumentById} with similar differences as mentioned above.
The third operation \emph{rewriteAndSaveProcessedDocumentById} has as input
parameters both document id and document text, because it overwrites the report
text stored in the database. It is intended to be called when the document has
been changed by others while being processed by the user, so the user can
force returning to the original version or provide new one. All three operations
take \emph{force} parameter specifying whether the saving should happen even
though there have been external changes to the database, e.g. new objects, new
relations and newly joined objects.

If the \emph{force} parameter is \emph{false} and such external changes have
been detected, saving returns \emph{false} and method \emph{getProblems} can be
called to get information about the changes. After making adjustments to
recognizing/assignments if needed, save operations can be called with
\emph{force} parameter set to \emph{true}.

For more details, consult the WSDL descriptions and Javadoc of the server
implementation.

\begin{figure}[!htb]
        \centering
        \includegraphics[width=\textwidth]{Images/ClientServerCommunication}
        \caption{Example of Client-Server communication during report processing.}
        \label{fig:ClientServerCommunication}
\end{figure}
